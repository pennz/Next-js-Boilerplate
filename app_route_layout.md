# Layout.tsx in Next.js App Router

The `layout.tsx` file is a fundamental concept in Next.js App Router that allows you to create shared UI that wraps multiple pages. Layouts provide a way to maintain state, avoid re-rendering shared components, and create consistent user experiences across different routes.

## What is a Layout?

A layout is a React component that wraps page components and other nested layouts. It's defined in a `layout.tsx` file and automatically applies to all pages and nested routes within its directory and subdirectories.

## Basic Layout Structure

```typescript
// app/layout.tsx (Root Layout)
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        <header>
          <nav>My App Navigation</nav>
        </header>
        <main>{children}</main>
        <footer>© 2024 My App</footer>
      </body>
    </html>
  )
}
```

## Layout Hierarchy

Layouts follow a nested hierarchy based on your folder structure:

```
app/
├── layout.tsx          // Root layout (wraps entire app)
├── page.tsx            // Home page
├── dashboard/
│   ├── layout.tsx      // Dashboard layout (wraps dashboard pages)
│   ├── page.tsx        // Dashboard home
│   ├── analytics/
│   │   └── page.tsx    // Analytics page
│   └── settings/
│       ├── layout.tsx  // Settings layout (wraps settings pages)
│       ├── page.tsx    // Settings home
│       └── profile/
│           └── page.tsx // Profile settings
```

**Resulting layout composition:**
- `/` uses: Root Layout
- `/dashboard` uses: Root Layout → Dashboard Layout
- `/dashboard/analytics` uses: Root Layout → Dashboard Layout
- `/dashboard/settings` uses: Root Layout → Dashboard Layout → Settings Layout
- `/dashboard/settings/profile` uses: Root Layout → Dashboard Layout → Settings Layout

## Types of Layouts

### 1. Root Layout (Required)

The root layout is **mandatory** and must be placed at `app/layout.tsx`. It defines the initial HTML structure:

```typescript
// app/layout.tsx
import './globals.css'

export const metadata = {
  title: 'My Next.js App',
  description: 'Generated by create next app',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        <div id="root">
          {children}
        </div>
      </body>
    </html>
  )
}
```

**Key Requirements:**
- Must include `<html>` and `<body>` tags
- Cannot be a client component (no `'use client'`)
- Applies to the entire application

### 2. Nested Layouts

Nested layouts apply to specific route segments and their children:

```typescript
// app/dashboard/layout.tsx
'use client' // This can be a client component

import { useState } from 'react'
import Sidebar from './components/Sidebar'

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  const [sidebarOpen, setSidebarOpen] = useState(true)

  return (
    <div className="flex">
      <Sidebar
        isOpen={sidebarOpen}
        onToggle={() => setSidebarOpen(!sidebarOpen)}
      />
      <div className="flex-1 p-6">
        <header className="mb-6">
          <h1>Dashboard</h1>
        </header>
        {children}
      </div>
    </div>
  )
}
```

### 3. Route Group Layouts

Use parentheses to create layouts that don't affect the URL structure:

```
app/
├── layout.tsx
├── (auth)/
│   ├── layout.tsx      // Auth layout
│   ├── login/
│   │   └── page.tsx    // URL: /login
│   └── register/
│       └── page.tsx    // URL: /register
└── (dashboard)/
    ├── layout.tsx      // Dashboard layout
    └── analytics/
        └── page.tsx    // URL: /analytics
```

```typescript
// app/(auth)/layout.tsx
export default function AuthLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full">
        <div className="text-center mb-8">
          <h1>Welcome</h1>
        </div>
        {children}
      </div>
    </div>
  )
}
```

## Layout Props and Features

### Children Prop
The primary prop layouts receive is `children`, which represents the page component or nested layout.

### Params Prop (Dynamic Layouts)
Layouts can access route parameters:

```typescript
// app/blog/[category]/layout.tsx
export default function CategoryLayout({
  children,
  params,
}: {
  children: React.ReactNode
  params: { category: string }
}) {
  return (
    <div>
      <h1>Category: {params.category}</h1>
      <nav>
        {/* Category-specific navigation */}
      </nav>
      {children}
    </div>
  )
}
```

### Metadata in Layouts
Layouts can export metadata that applies to all child pages:

```typescript
// app/dashboard/layout.tsx
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: {
    template: '%s | Dashboard',
    default: 'Dashboard',
  },
  description: 'Dashboard for managing your account',
}

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return <div>{children}</div>
}
```

## Advanced Layout Patterns

### Conditional Layouts
You can conditionally render different layouts:

```typescript
// app/layout.tsx
import AdminLayout from './components/AdminLayout'
import UserLayout from './components/UserLayout'
import { getCurrentUser } from './lib/auth'

export default async function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  const user = await getCurrentUser()

  const LayoutComponent = user?.role === 'admin' ? AdminLayout : UserLayout

  return (
    <html lang="en">
      <body>
        <LayoutComponent>{children}</LayoutComponent>
      </body>
    </html>
  )
}
```

### Layout with Multiple Slots
Use parallel routes for complex layouts:

```
app/
├── layout.tsx
├── @sidebar/
│   └── page.tsx
├── @content/
│   └── page.tsx
└── page.tsx
```

```typescript
// app/layout.tsx
export default function Layout({
  children,
  sidebar,
  content,
}: {
  children: React.ReactNode
  sidebar: React.ReactNode
  content: React.ReactNode
}) {
  return (
    <div className="flex">
      <div className="w-64">{sidebar}</div>
      <div className="flex-1">
        {content}
        {children}
      </div>
    </div>
  )
}
```

### Layout with Context Providers
Layouts are perfect for providing context:

```typescript
// app/dashboard/layout.tsx
'use client'

import { createContext, useContext, useState } from 'react'

const DashboardContext = createContext({})

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  const [user, setUser] = useState(null)
  const [notifications, setNotifications] = useState([])

  return (
    <DashboardContext.Provider value={{
      user,
      setUser,
      notifications,
      setNotifications
    }}>
      <div className="dashboard-layout">
        {children}
      </div>
    </DashboardContext.Provider>
  )
}

export function useDashboard() {
  return useContext(DashboardContext)
}
```

## Layout Persistence and State

One of the key benefits of layouts is that they maintain state and don't re-render when navigating between pages that share the same layout:

```typescript
// app/dashboard/layout.tsx
'use client'

import { useState } from 'react'

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  // This state persists across page navigations within the dashboard
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false)

  return (
    <div className="flex">
      <aside className={sidebarCollapsed ? 'w-16' : 'w-64'}>
        <button onClick={() => setSidebarCollapsed(!sidebarCollapsed)}>
          Toggle
        </button>
        {/* Sidebar content */}
      </aside>
      <main className="flex-1">
        {children}
      </main>
    </div>
  )
}
```

## Best Practices

### 1. Keep Layouts Focused
Each layout should have a single responsibility:
```typescript
// Good: Focused on authentication layout
export default function AuthLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="auth-container">
      <AuthProvider>
        {children}
      </AuthProvider>
    </div>
  )
}
```

### 2. Use TypeScript for Better DX
```typescript
interface LayoutProps {
  children: React.ReactNode
  params?: { [key: string]: string }
}

export default function Layout({ children, params }: LayoutProps) {
  return <div>{children}</div>
}
```

### 3. Handle Loading and Error States
```typescript
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div>
      <nav>Dashboard Navigation</nav>
      <Suspense fallback={<Loading />}>
        <ErrorBoundary fallback={<Error />}>
          {children}
        </ErrorBoundary>
      </Suspense>
    </div>
  )
}
```

### 4. Optimize Performance
- Use `loading.tsx` and `error.tsx` files alongside layouts
- Implement proper code splitting
- Use React.memo for expensive layout components

## Differences from Pages Router

Unlike the Pages Router's `_app.tsx` and `_document.tsx`, App Router layouts:
- Are more granular and can be nested
- Support both server and client components
- Maintain state during navigation
- Can be applied to specific route segments
- Support parallel rendering with multiple slots

Layout.tsx files in the App Router provide a powerful, flexible way to structure your Next.js application with shared UI, persistent state, and optimal performance characteristics.
